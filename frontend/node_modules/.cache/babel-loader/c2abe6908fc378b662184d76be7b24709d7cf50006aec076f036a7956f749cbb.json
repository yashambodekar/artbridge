{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CursorTimeoutContext = exports.AbstractCursor = exports.CursorTimeoutMode = exports.CURSOR_FLAGS = void 0;\nconst stream_1 = require(\"stream\");\nconst bson_1 = require(\"../bson\");\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst get_more_1 = require(\"../operations/get_more\");\nconst kill_cursors_1 = require(\"../operations/kill_cursors\");\nconst read_concern_1 = require(\"../read_concern\");\nconst read_preference_1 = require(\"../read_preference\");\nconst resource_management_1 = require(\"../resource_management\");\nconst sessions_1 = require(\"../sessions\");\nconst timeout_1 = require(\"../timeout\");\nconst utils_1 = require(\"../utils\");\n/** @public */\nexports.CURSOR_FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];\nfunction removeActiveCursor() {\n  this.client.s.activeCursors.delete(this);\n}\n/**\n * @public\n * @experimental\n * Specifies how `timeoutMS` is applied to the cursor. Can be either `'cursorLifeTime'` or `'iteration'`\n * When set to `'iteration'`, the deadline specified by `timeoutMS` applies to each call of\n * `cursor.next()`.\n * When set to `'cursorLifetime'`, the deadline applies to the life of the entire cursor.\n *\n * Depending on the type of cursor being used, this option has different default values.\n * For non-tailable cursors, this value defaults to `'cursorLifetime'`\n * For tailable cursors, this value defaults to `'iteration'` since tailable cursors, by\n * definition can have an arbitrarily long lifetime.\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, {timeoutMS: 100, timeoutMode: 'iteration'});\n * for await (const doc of cursor) {\n *  // process doc\n *  // This will throw a timeout error if any of the iterator's `next()` calls takes more than 100ms, but\n *  // will continue to iterate successfully otherwise, regardless of the number of batches.\n * }\n * ```\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, { timeoutMS: 1000, timeoutMode: 'cursorLifetime' });\n * const docs = await cursor.toArray(); // This entire line will throw a timeout error if all batches are not fetched and returned within 1000ms.\n * ```\n */\nexports.CursorTimeoutMode = Object.freeze({\n  ITERATION: 'iteration',\n  LIFETIME: 'cursorLifetime'\n});\n/** @public */\nclass AbstractCursor extends mongo_types_1.TypedEventEmitter {\n  /** @internal */\n  constructor(client, namespace, options = {}) {\n    super();\n    /** @internal */\n    this.documents = null;\n    /** @internal */\n    this.hasEmittedClose = false;\n    this.on('error', utils_1.noop);\n    if (!client.s.isMongoClient) {\n      throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n    this.cursorClient = client;\n    this.cursorNamespace = namespace;\n    this.cursorId = null;\n    this.initialized = false;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.cursorOptions = {\n      readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,\n      ...(0, bson_1.pluckBSONSerializeOptions)(options),\n      timeoutMS: options?.timeoutContext?.csotEnabled() ? options.timeoutContext.timeoutMS : options.timeoutMS,\n      tailable: options.tailable,\n      awaitData: options.awaitData\n    };\n    if (this.cursorOptions.timeoutMS != null) {\n      if (options.timeoutMode == null) {\n        if (options.tailable) {\n          if (options.awaitData) {\n            if (options.maxAwaitTimeMS != null && options.maxAwaitTimeMS >= this.cursorOptions.timeoutMS) throw new error_1.MongoInvalidArgumentError('Cannot specify maxAwaitTimeMS >= timeoutMS for a tailable awaitData cursor');\n          }\n          this.cursorOptions.timeoutMode = exports.CursorTimeoutMode.ITERATION;\n        } else {\n          this.cursorOptions.timeoutMode = exports.CursorTimeoutMode.LIFETIME;\n        }\n      } else {\n        if (options.tailable && options.timeoutMode === exports.CursorTimeoutMode.LIFETIME) {\n          throw new error_1.MongoInvalidArgumentError(\"Cannot set tailable cursor's timeoutMode to LIFETIME\");\n        }\n        this.cursorOptions.timeoutMode = options.timeoutMode;\n      }\n    } else {\n      if (options.timeoutMode != null) throw new error_1.MongoInvalidArgumentError('Cannot set timeoutMode without setting timeoutMS');\n    }\n    // Set for initial command\n    this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null && (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && !this.cursorOptions.tailable || this.cursorOptions.tailable && !this.cursorOptions.awaitData);\n    const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this.cursorOptions.readConcern = readConcern;\n    }\n    if (typeof options.batchSize === 'number') {\n      this.cursorOptions.batchSize = options.batchSize;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this.cursorOptions.comment = options.comment;\n    }\n    if (typeof options.maxTimeMS === 'number') {\n      this.cursorOptions.maxTimeMS = options.maxTimeMS;\n    }\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      this.cursorOptions.maxAwaitTimeMS = options.maxAwaitTimeMS;\n    }\n    if (options.session instanceof sessions_1.ClientSession) {\n      this.cursorSession = options.session;\n    } else {\n      this.cursorSession = this.cursorClient.startSession({\n        owner: this,\n        explicit: false\n      });\n    }\n    this.deserializationOptions = {\n      ...this.cursorOptions,\n      validation: {\n        utf8: options?.enableUtf8Validation === false ? false : true\n      }\n    };\n    this.timeoutContext = options.timeoutContext;\n    this.signal = options.signal;\n    this.abortListener = (0, utils_1.addAbortListener)(this.signal, () => void this.close().then(undefined, utils_1.squashError));\n    this.trackCursor();\n  }\n  /**\n   * The cursor has no id until it receives a response from the initial cursor creating command.\n   *\n   * It is non-zero for as long as the database has an open cursor.\n   *\n   * The initiating command may receive a zero id if the entire result is in the `firstBatch`.\n   */\n  get id() {\n    return this.cursorId ?? undefined;\n  }\n  /** @internal */\n  get isDead() {\n    return (this.cursorId?.isZero() ?? false) || this.isClosed || this.isKilled;\n  }\n  /** @internal */\n  get client() {\n    return this.cursorClient;\n  }\n  /** @internal */\n  get server() {\n    return this.selectedServer;\n  }\n  get namespace() {\n    return this.cursorNamespace;\n  }\n  get readPreference() {\n    return this.cursorOptions.readPreference;\n  }\n  get readConcern() {\n    return this.cursorOptions.readConcern;\n  }\n  /** @internal */\n  get session() {\n    return this.cursorSession;\n  }\n  set session(clientSession) {\n    this.cursorSession = clientSession;\n  }\n  /**\n   * The cursor is closed and all remaining locally buffered documents have been iterated.\n   */\n  get closed() {\n    return this.isClosed && (this.documents?.length ?? 0) === 0;\n  }\n  /**\n   * A `killCursors` command was attempted on this cursor.\n   * This is performed if the cursor id is non zero.\n   */\n  get killed() {\n    return this.isKilled;\n  }\n  get loadBalanced() {\n    return !!this.cursorClient.topology?.loadBalanced;\n  }\n  /** @internal */\n  async asyncDispose() {\n    await this.close();\n  }\n  /** Adds cursor to client's tracking so it will be closed by MongoClient.close() */\n  trackCursor() {\n    this.cursorClient.s.activeCursors.add(this);\n    if (!this.listeners('close').includes(removeActiveCursor)) {\n      this.once('close', removeActiveCursor);\n    }\n  }\n  /** Returns current buffered documents length */\n  bufferedCount() {\n    return this.documents?.length ?? 0;\n  }\n  /** Returns current buffered documents */\n  readBufferedDocuments(number) {\n    const bufferedDocs = [];\n    const documentsToRead = Math.min(number ?? this.documents?.length ?? 0, this.documents?.length ?? 0);\n    for (let count = 0; count < documentsToRead; count++) {\n      const document = this.documents?.shift(this.deserializationOptions);\n      if (document != null) {\n        bufferedDocs.push(document);\n      }\n    }\n    return bufferedDocs;\n  }\n  async *[Symbol.asyncIterator]() {\n    this.signal?.throwIfAborted();\n    if (this.closed) {\n      return;\n    }\n    try {\n      while (true) {\n        if (this.isKilled) {\n          return;\n        }\n        if (this.closed) {\n          return;\n        }\n        if (this.cursorId != null && this.isDead && (this.documents?.length ?? 0) === 0) {\n          return;\n        }\n        const document = await this.next();\n        // eslint-disable-next-line no-restricted-syntax\n        if (document === null) {\n          return;\n        }\n        yield document;\n        this.signal?.throwIfAborted();\n      }\n    } finally {\n      // Only close the cursor if it has not already been closed. This finally clause handles\n      // the case when a user would break out of a for await of loop early.\n      if (!this.isClosed) {\n        try {\n          await this.close();\n        } catch (error) {\n          (0, utils_1.squashError)(error);\n        }\n      }\n    }\n  }\n  stream(options) {\n    const readable = new ReadableCursorStream(this);\n    const abortListener = (0, utils_1.addAbortListener)(this.signal, function () {\n      readable.destroy(this.reason);\n    });\n    readable.once('end', () => {\n      abortListener?.[utils_1.kDispose]();\n    });\n    if (options?.transform) {\n      const transform = options.transform;\n      const transformedStream = readable.pipe(new stream_1.Transform({\n        objectMode: true,\n        highWaterMark: 1,\n        transform(chunk, _, callback) {\n          try {\n            const transformed = transform(chunk);\n            callback(undefined, transformed);\n          } catch (err) {\n            callback(err);\n          }\n        }\n      }));\n      // Bubble errors to transformed stream, because otherwise no way\n      // to handle this error.\n      readable.on('error', err => transformedStream.emit('error', err));\n      return transformedStream;\n    }\n    return readable;\n  }\n  async hasNext() {\n    this.signal?.throwIfAborted();\n    if (this.cursorId === bson_1.Long.ZERO) {\n      return false;\n    }\n    if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n    try {\n      do {\n        if ((this.documents?.length ?? 0) !== 0) {\n          return true;\n        }\n        await this.fetchBatch();\n      } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n    } finally {\n      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n    return false;\n  }\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n  async next() {\n    this.signal?.throwIfAborted();\n    if (this.cursorId === bson_1.Long.ZERO) {\n      throw new error_1.MongoCursorExhaustedError();\n    }\n    if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n    try {\n      do {\n        const doc = this.documents?.shift(this.deserializationOptions);\n        if (doc != null) {\n          if (this.transform != null) return await this.transformDocument(doc);\n          return doc;\n        }\n        await this.fetchBatch();\n      } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n    } finally {\n      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n    return null;\n  }\n  /**\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\n   */\n  async tryNext() {\n    this.signal?.throwIfAborted();\n    if (this.cursorId === bson_1.Long.ZERO) {\n      throw new error_1.MongoCursorExhaustedError();\n    }\n    if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n    try {\n      let doc = this.documents?.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n      await this.fetchBatch();\n      doc = this.documents?.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n    } finally {\n      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n    return null;\n  }\n  /**\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\n   *\n   * If the iterator returns `false`, iteration will stop.\n   *\n   * @param iterator - The iteration callback.\n   * @deprecated - Will be removed in a future release. Use for await...of instead.\n   */\n  async forEach(iterator) {\n    this.signal?.throwIfAborted();\n    if (typeof iterator !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n    for await (const document of this) {\n      const result = iterator(document);\n      if (result === false) {\n        break;\n      }\n    }\n  }\n  /**\n   * Frees any client-side resources used by the cursor.\n   */\n  async close(options) {\n    await this.cleanup(options?.timeoutMS);\n  }\n  /**\n   * Returns an array of documents. The caller is responsible for making sure that there\n   * is enough memory to store the results. Note that the array only contains partial\n   * results when this cursor had been previously accessed. In that case,\n   * cursor.rewind() can be used to reset the cursor.\n   */\n  async toArray() {\n    this.signal?.throwIfAborted();\n    const array = [];\n    // at the end of the loop (since readBufferedDocuments is called) the buffer will be empty\n    // then, the 'await of' syntax will run a getMore call\n    for await (const document of this) {\n      array.push(document);\n      const docs = this.readBufferedDocuments();\n      if (this.transform != null) {\n        for (const doc of docs) {\n          array.push(await this.transformDocument(doc));\n        }\n      } else {\n        array.push(...docs);\n      }\n    }\n    return array;\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag, value) {\n    this.throwIfInitialized();\n    if (!exports.CURSOR_FLAGS.includes(flag)) {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);\n    }\n    if (typeof value !== 'boolean') {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n    this.cursorOptions[flag] = value;\n    return this;\n  }\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   *\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => null);\n   *\n   * const documents = await cursor.toArray();\n   * // documents is always [], regardless of how many documents are in the collection.\n   * ```\n   *\n   * Other falsey values are allowed:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => '');\n   *\n   * const documents = await cursor.toArray();\n   * // documents is now an array of empty strings\n   * ```\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map(transform) {\n    this.throwIfInitialized();\n    const oldTransform = this.transform;\n    if (oldTransform) {\n      this.transform = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this.transform = transform;\n    }\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference) {\n    this.throwIfInitialized();\n    if (readPreference instanceof read_preference_1.ReadPreference) {\n      this.cursorOptions.readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this.cursorOptions.readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n    } else {\n      throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern) {\n    this.throwIfInitialized();\n    const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({\n      readConcern\n    });\n    if (resolvedReadConcern) {\n      this.cursorOptions.readConcern = resolvedReadConcern;\n    }\n    return this;\n  }\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value) {\n    this.throwIfInitialized();\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n    this.cursorOptions.maxTimeMS = value;\n    return this;\n  }\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value) {\n    this.throwIfInitialized();\n    if (this.cursorOptions.tailable) {\n      throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n    this.cursorOptions.batchSize = value;\n    return this;\n  }\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind() {\n    if (this.timeoutContext && this.timeoutContext.owner !== this) {\n      throw new error_1.MongoAPIError(`Cannot rewind cursor that does not own its timeout context.`);\n    }\n    if (!this.initialized) {\n      return;\n    }\n    this.cursorId = null;\n    this.documents?.clear();\n    this.timeoutContext?.clear();\n    this.timeoutContext = undefined;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.initialized = false;\n    this.hasEmittedClose = false;\n    this.trackCursor();\n    // We only want to end this session if we created it, and it hasn't ended yet\n    if (this.cursorSession.explicit === false) {\n      if (!this.cursorSession.hasEnded) {\n        this.cursorSession.endSession().then(undefined, utils_1.squashError);\n      }\n      this.cursorSession = this.cursorClient.startSession({\n        owner: this,\n        explicit: false\n      });\n    }\n  }\n  /** @internal */\n  async getMore(batchSize) {\n    if (this.cursorId == null) {\n      throw new error_1.MongoRuntimeError('Unexpected null cursor id. A cursor creating command should have set this');\n    }\n    if (this.selectedServer == null) {\n      throw new error_1.MongoRuntimeError('Unexpected null selectedServer. A cursor creating command should have set this');\n    }\n    const getMoreOptions = {\n      ...this.cursorOptions,\n      session: this.cursorSession,\n      batchSize\n    };\n    const getMoreOperation = new get_more_1.GetMoreOperation(this.cursorNamespace, this.cursorId, this.selectedServer, getMoreOptions);\n    return await (0, execute_operation_1.executeOperation)(this.cursorClient, getMoreOperation, this.timeoutContext);\n  }\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n  async cursorInit() {\n    if (this.cursorOptions.timeoutMS != null) {\n      this.timeoutContext ??= new CursorTimeoutContext(timeout_1.TimeoutContext.create({\n        serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,\n        timeoutMS: this.cursorOptions.timeoutMS\n      }), this);\n    }\n    try {\n      const state = await this._initialize(this.cursorSession);\n      // Set omitMaxTimeMS to the value needed for subsequent getMore calls\n      this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null;\n      const response = state.response;\n      this.selectedServer = state.server;\n      this.cursorId = response.id;\n      this.cursorNamespace = response.ns ?? this.namespace;\n      this.documents = response;\n      this.initialized = true; // the cursor is now initialized, even if it is dead\n    } catch (error) {\n      // the cursor is now initialized, even if an error occurred\n      this.initialized = true;\n      await this.cleanup(undefined, error);\n      throw error;\n    }\n    if (this.isDead) {\n      await this.cleanup();\n    }\n    return;\n  }\n  /** @internal Attempt to obtain more documents */\n  async fetchBatch() {\n    if (this.isClosed) {\n      return;\n    }\n    if (this.isDead) {\n      // if the cursor is dead, we clean it up\n      // cleanupCursor should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n      return;\n    }\n    if (this.cursorId == null) {\n      await this.cursorInit();\n      // If the cursor died or returned documents, return\n      if ((this.documents?.length ?? 0) !== 0 || this.isDead) return;\n      // Otherwise, run a getMore\n    }\n    // otherwise need to call getMore\n    const batchSize = this.cursorOptions.batchSize || 1000;\n    try {\n      const response = await this.getMore(batchSize);\n      this.cursorId = response.id;\n      this.documents = response;\n    } catch (error) {\n      try {\n        await this.cleanup(undefined, error);\n      } catch (cleanupError) {\n        // `cleanupCursor` should never throw, squash and throw the original error\n        (0, utils_1.squashError)(cleanupError);\n      }\n      throw error;\n    }\n    if (this.isDead) {\n      // If we successfully received a response from a cursor BUT the cursor indicates that it is exhausted,\n      // we intentionally clean up the cursor to release its session back into the pool before the cursor\n      // is iterated.  This prevents a cursor that is exhausted on the server from holding\n      // onto a session indefinitely until the AbstractCursor is iterated.\n      //\n      // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n    }\n  }\n  /** @internal */\n  async cleanup(timeoutMS, error) {\n    this.abortListener?.[utils_1.kDispose]();\n    this.isClosed = true;\n    const timeoutContextForKillCursors = () => {\n      if (timeoutMS != null) {\n        this.timeoutContext?.clear();\n        return new CursorTimeoutContext(timeout_1.TimeoutContext.create({\n          serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,\n          timeoutMS\n        }), this);\n      } else {\n        return this.timeoutContext?.refreshed();\n      }\n    };\n    try {\n      if (!this.isKilled && this.cursorId && !this.cursorId.isZero() && this.cursorNamespace && this.selectedServer && !this.cursorSession.hasEnded) {\n        this.isKilled = true;\n        const cursorId = this.cursorId;\n        this.cursorId = bson_1.Long.ZERO;\n        await (0, execute_operation_1.executeOperation)(this.cursorClient, new kill_cursors_1.KillCursorsOperation(cursorId, this.cursorNamespace, this.selectedServer, {\n          session: this.cursorSession\n        }), timeoutContextForKillCursors());\n      }\n    } catch (error) {\n      (0, utils_1.squashError)(error);\n    } finally {\n      try {\n        if (this.cursorSession?.owner === this) {\n          await this.cursorSession.endSession({\n            error\n          });\n        }\n        if (!this.cursorSession?.inTransaction()) {\n          (0, sessions_1.maybeClearPinnedConnection)(this.cursorSession, {\n            error\n          });\n        }\n      } finally {\n        this.emitClose();\n      }\n    }\n  }\n  /** @internal */\n  emitClose() {\n    try {\n      if (!this.hasEmittedClose && ((this.documents?.length ?? 0) === 0 || this.isClosed)) {\n        // @ts-expect-error: CursorEvents is generic so Parameters<CursorEvents[\"close\"]> may not be assignable to `[]`. Not sure how to require extenders do not add parameters.\n        this.emit('close');\n      }\n    } finally {\n      this.hasEmittedClose = true;\n    }\n  }\n  /** @internal */\n  async transformDocument(document) {\n    if (this.transform == null) return document;\n    try {\n      const transformedDocument = this.transform(document);\n      // eslint-disable-next-line no-restricted-syntax\n      if (transformedDocument === null) {\n        const TRANSFORM_TO_NULL_ERROR = 'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\n        throw new error_1.MongoAPIError(TRANSFORM_TO_NULL_ERROR);\n      }\n      return transformedDocument;\n    } catch (transformError) {\n      try {\n        await this.close();\n      } catch (closeError) {\n        (0, utils_1.squashError)(closeError);\n      }\n      throw transformError;\n    }\n  }\n  /** @internal */\n  throwIfInitialized() {\n    if (this.initialized) throw new error_1.MongoCursorInUseError();\n  }\n}\nexports.AbstractCursor = AbstractCursor;\n/** @event */\nAbstractCursor.CLOSE = 'close';\nclass ReadableCursorStream extends stream_1.Readable {\n  constructor(cursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._readInProgress = false;\n    this._cursor = cursor;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _read(size) {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n      this._readNext();\n    }\n  }\n  _destroy(error, callback) {\n    this._cursor.close().then(() => callback(error), closeError => callback(closeError));\n  }\n  _readNext() {\n    if (this._cursor.id === bson_1.Long.ZERO) {\n      this.push(null);\n      return;\n    }\n    this._cursor.next().then(result => {\n      if (result == null) {\n        this.push(null);\n      } else if (this.destroyed) {\n        this._cursor.close().then(undefined, utils_1.squashError);\n      } else {\n        if (this.push(result)) {\n          return this._readNext();\n        }\n        this._readInProgress = false;\n      }\n    }, err => {\n      // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n      //       desired behavior is that a stream ends cleanly when a user explicitly closes\n      //       a client during iteration. Alternatively, we could do the \"right\" thing and\n      //       propagate the error message by removing this special case.\n      if (err.message.match(/server is closed/)) {\n        this._cursor.close().then(undefined, utils_1.squashError);\n        return this.push(null);\n      }\n      // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n      //       to be \"operation was interrupted\", where a cursor has been closed but there is an\n      //       active getMore in-flight. This used to check if the cursor was killed but once\n      //       that changed to happen in cleanup legitimate errors would not destroy the\n      //       stream. There are change streams test specifically test these cases.\n      if (err.message.match(/operation was interrupted/)) {\n        return this.push(null);\n      }\n      // NOTE: The two above checks on the message of the error will cause a null to be pushed\n      //       to the stream, thus closing the stream before the destroy call happens. This means\n      //       that either of those error messages on a change stream will not get a proper\n      //       'error' event to be emitted (the error passed to destroy). Change stream resumability\n      //       relies on that error event to be emitted to create its new cursor and thus was not\n      //       working on 4.4 servers because the error emitted on failover was \"interrupted at\n      //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\n      //       See NODE-4475.\n      return this.destroy(err);\n    });\n  }\n}\n(0, resource_management_1.configureResourceManagement)(AbstractCursor.prototype);\n/**\n * @internal\n * The cursor timeout context is a wrapper around a timeout context\n * that keeps track of the \"owner\" of the cursor.  For timeout contexts\n * instantiated inside a cursor, the owner will be the cursor.\n *\n * All timeout behavior is exactly the same as the wrapped timeout context's.\n */\nclass CursorTimeoutContext extends timeout_1.TimeoutContext {\n  constructor(timeoutContext, owner) {\n    super();\n    this.timeoutContext = timeoutContext;\n    this.owner = owner;\n  }\n  get serverSelectionTimeout() {\n    return this.timeoutContext.serverSelectionTimeout;\n  }\n  get connectionCheckoutTimeout() {\n    return this.timeoutContext.connectionCheckoutTimeout;\n  }\n  get clearServerSelectionTimeout() {\n    return this.timeoutContext.clearServerSelectionTimeout;\n  }\n  get timeoutForSocketWrite() {\n    return this.timeoutContext.timeoutForSocketWrite;\n  }\n  get timeoutForSocketRead() {\n    return this.timeoutContext.timeoutForSocketRead;\n  }\n  csotEnabled() {\n    return this.timeoutContext.csotEnabled();\n  }\n  refresh() {\n    if (typeof this.owner !== 'symbol') return this.timeoutContext.refresh();\n  }\n  clear() {\n    if (typeof this.owner !== 'symbol') return this.timeoutContext.clear();\n  }\n  get maxTimeMS() {\n    return this.timeoutContext.maxTimeMS;\n  }\n  get timeoutMS() {\n    return this.timeoutContext.csotEnabled() ? this.timeoutContext.timeoutMS : null;\n  }\n  refreshed() {\n    return new CursorTimeoutContext(this.timeoutContext.refreshed(), this.owner);\n  }\n  addMaxTimeMSToCommand(command, options) {\n    this.timeoutContext.addMaxTimeMSToCommand(command, options);\n  }\n  getSocketTimeoutMS() {\n    return this.timeoutContext.getSocketTimeoutMS();\n  }\n}\nexports.CursorTimeoutContext = CursorTimeoutContext;","map":{"version":3,"names":["stream_1","require","bson_1","error_1","mongo_types_1","execute_operation_1","get_more_1","kill_cursors_1","read_concern_1","read_preference_1","resource_management_1","sessions_1","timeout_1","utils_1","exports","CURSOR_FLAGS","removeActiveCursor","client","s","activeCursors","delete","CursorTimeoutMode","Object","freeze","ITERATION","LIFETIME","AbstractCursor","TypedEventEmitter","constructor","namespace","options","documents","hasEmittedClose","on","noop","isMongoClient","MongoRuntimeError","cursorClient","cursorNamespace","cursorId","initialized","isClosed","isKilled","cursorOptions","readPreference","ReadPreference","primary","pluckBSONSerializeOptions","timeoutMS","timeoutContext","csotEnabled","tailable","awaitData","timeoutMode","maxAwaitTimeMS","MongoInvalidArgumentError","omitMaxTimeMS","readConcern","ReadConcern","fromOptions","batchSize","comment","undefined","maxTimeMS","session","ClientSession","cursorSession","startSession","owner","explicit","deserializationOptions","validation","utf8","enableUtf8Validation","signal","abortListener","addAbortListener","close","then","squashError","trackCursor","id","isDead","isZero","server","selectedServer","clientSession","closed","length","killed","loadBalanced","topology","asyncDispose","add","listeners","includes","once","bufferedCount","readBufferedDocuments","number","bufferedDocs","documentsToRead","Math","min","count","document","shift","push","Symbol","asyncIterator","throwIfAborted","next","error","stream","readable","ReadableCursorStream","destroy","reason","kDispose","transform","transformedStream","pipe","Transform","objectMode","highWaterMark","chunk","_","callback","transformed","err","emit","hasNext","Long","ZERO","refresh","fetchBatch","clear","MongoCursorExhaustedError","doc","transformDocument","tryNext","forEach","iterator","result","cleanup","toArray","array","docs","addCursorFlag","flag","value","throwIfInitialized","map","oldTransform","withReadPreference","fromString","withReadConcern","resolvedReadConcern","MongoTailableCursorError","rewind","MongoAPIError","hasEnded","endSession","getMore","getMoreOptions","getMoreOperation","GetMoreOperation","executeOperation","cursorInit","CursorTimeoutContext","TimeoutContext","create","serverSelectionTimeoutMS","state","_initialize","response","ns","cleanupError","timeoutContextForKillCursors","refreshed","KillCursorsOperation","inTransaction","maybeClearPinnedConnection","emitClose","transformedDocument","TRANSFORM_TO_NULL_ERROR","transformError","closeError","MongoCursorInUseError","CLOSE","Readable","cursor","autoDestroy","_readInProgress","_cursor","_read","size","_readNext","_destroy","destroyed","message","match","configureResourceManagement","prototype","serverSelectionTimeout","connectionCheckoutTimeout","clearServerSelectionTimeout","timeoutForSocketWrite","timeoutForSocketRead","addMaxTimeMSToCommand","command","getSocketTimeoutMS"],"sources":["C:\\Users\\HP\\node_modules\\mongodb\\src\\cursor\\abstract_cursor.ts"],"sourcesContent":["import { Readable, Transform } from 'stream';\n\nimport { type BSONSerializeOptions, type Document, Long, pluckBSONSerializeOptions } from '../bson';\nimport { type OnDemandDocumentDeserializeOptions } from '../cmap/wire_protocol/on_demand/document';\nimport { type CursorResponse } from '../cmap/wire_protocol/responses';\nimport {\n  MongoAPIError,\n  MongoCursorExhaustedError,\n  MongoCursorInUseError,\n  MongoInvalidArgumentError,\n  MongoRuntimeError,\n  MongoTailableCursorError\n} from '../error';\nimport type { MongoClient } from '../mongo_client';\nimport { type Abortable, TypedEventEmitter } from '../mongo_types';\nimport { executeOperation } from '../operations/execute_operation';\nimport { GetMoreOperation } from '../operations/get_more';\nimport { KillCursorsOperation } from '../operations/kill_cursors';\nimport { ReadConcern, type ReadConcernLike } from '../read_concern';\nimport { ReadPreference, type ReadPreferenceLike } from '../read_preference';\nimport { type AsyncDisposable, configureResourceManagement } from '../resource_management';\nimport type { Server } from '../sdam/server';\nimport { ClientSession, maybeClearPinnedConnection } from '../sessions';\nimport { type CSOTTimeoutContext, type Timeout, TimeoutContext } from '../timeout';\nimport {\n  addAbortListener,\n  type Disposable,\n  kDispose,\n  type MongoDBNamespace,\n  noop,\n  squashError\n} from '../utils';\n\n/**\n * @internal\n * TODO(NODE-2882): A cursor's getMore commands must be run on the same server it was started on\n * and the same session must be used for the lifetime of the cursor. This object serves to get the\n * server and session (along with the response) out of executeOperation back to the AbstractCursor.\n *\n * There may be a better design for communicating these values back to the cursor, currently an operation\n * MUST store the selected server on itself so it can be read after executeOperation has returned.\n */\nexport interface InitialCursorResponse {\n  /** The server selected for the operation */\n  server: Server;\n  /** The session used for this operation, may be implicitly created */\n  session?: ClientSession;\n  /** The raw server response for the operation */\n  response: CursorResponse;\n}\n\n/** @public */\nexport const CURSOR_FLAGS = [\n  'tailable',\n  'oplogReplay',\n  'noCursorTimeout',\n  'awaitData',\n  'exhaust',\n  'partial'\n] as const;\n\n/** @public */\nexport interface CursorStreamOptions {\n  /** A transformation method applied to each document emitted by the stream */\n  transform?(this: void, doc: Document): Document;\n}\n\n/** @public */\nexport type CursorFlag = (typeof CURSOR_FLAGS)[number];\n\nfunction removeActiveCursor(this: AbstractCursor) {\n  this.client.s.activeCursors.delete(this);\n}\n\n/**\n * @public\n * @experimental\n * Specifies how `timeoutMS` is applied to the cursor. Can be either `'cursorLifeTime'` or `'iteration'`\n * When set to `'iteration'`, the deadline specified by `timeoutMS` applies to each call of\n * `cursor.next()`.\n * When set to `'cursorLifetime'`, the deadline applies to the life of the entire cursor.\n *\n * Depending on the type of cursor being used, this option has different default values.\n * For non-tailable cursors, this value defaults to `'cursorLifetime'`\n * For tailable cursors, this value defaults to `'iteration'` since tailable cursors, by\n * definition can have an arbitrarily long lifetime.\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, {timeoutMS: 100, timeoutMode: 'iteration'});\n * for await (const doc of cursor) {\n *  // process doc\n *  // This will throw a timeout error if any of the iterator's `next()` calls takes more than 100ms, but\n *  // will continue to iterate successfully otherwise, regardless of the number of batches.\n * }\n * ```\n *\n * @example\n * ```ts\n * const cursor = collection.find({}, { timeoutMS: 1000, timeoutMode: 'cursorLifetime' });\n * const docs = await cursor.toArray(); // This entire line will throw a timeout error if all batches are not fetched and returned within 1000ms.\n * ```\n */\nexport const CursorTimeoutMode = Object.freeze({\n  ITERATION: 'iteration',\n  LIFETIME: 'cursorLifetime'\n} as const);\n\n/**\n * @public\n * @experimental\n */\nexport type CursorTimeoutMode = (typeof CursorTimeoutMode)[keyof typeof CursorTimeoutMode];\n\n/** @public */\nexport interface AbstractCursorOptions extends BSONSerializeOptions {\n  session?: ClientSession;\n  readPreference?: ReadPreferenceLike;\n  readConcern?: ReadConcernLike;\n  /**\n   * Specifies the number of documents to return in each response from MongoDB\n   */\n  batchSize?: number;\n  /**\n   * When applicable `maxTimeMS` controls the amount of time the initial command\n   * that constructs a cursor should take. (ex. find, aggregate, listCollections)\n   */\n  maxTimeMS?: number;\n  /**\n   * When applicable `maxAwaitTimeMS` controls the amount of time subsequent getMores\n   * that a cursor uses to fetch more data should take. (ex. cursor.next())\n   */\n  maxAwaitTimeMS?: number;\n  /**\n   * Comment to apply to the operation.\n   *\n   * In server versions pre-4.4, 'comment' must be string.  A server\n   * error will be thrown if any other type is provided.\n   *\n   * In server versions 4.4 and above, 'comment' can be any valid BSON type.\n   */\n  comment?: unknown;\n  /**\n   * By default, MongoDB will automatically close a cursor when the\n   * client has exhausted all results in the cursor. However, for [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections)\n   * you may use a Tailable Cursor that remains open after the client exhausts\n   * the results in the initial cursor.\n   */\n  tailable?: boolean;\n  /**\n   * If awaitData is set to true, when the cursor reaches the end of the capped collection,\n   * MongoDB blocks the query thread for a period of time waiting for new data to arrive.\n   * When new data is inserted into the capped collection, the blocked thread is signaled\n   * to wake up and return the next batch to the client.\n   */\n  awaitData?: boolean;\n  noCursorTimeout?: boolean;\n  /** Specifies the time an operation will run until it throws a timeout error. See {@link AbstractCursorOptions.timeoutMode} for more details on how this option applies to cursors. */\n  timeoutMS?: number;\n  /**\n   * @public\n   * @experimental\n   * Specifies how `timeoutMS` is applied to the cursor. Can be either `'cursorLifeTime'` or `'iteration'`\n   * When set to `'iteration'`, the deadline specified by `timeoutMS` applies to each call of\n   * `cursor.next()`.\n   * When set to `'cursorLifetime'`, the deadline applies to the life of the entire cursor.\n   *\n   * Depending on the type of cursor being used, this option has different default values.\n   * For non-tailable cursors, this value defaults to `'cursorLifetime'`\n   * For tailable cursors, this value defaults to `'iteration'` since tailable cursors, by\n   * definition can have an arbitrarily long lifetime.\n   *\n   * @example\n   * ```ts\n   * const cursor = collection.find({}, {timeoutMS: 100, timeoutMode: 'iteration'});\n   * for await (const doc of cursor) {\n   *  // process doc\n   *  // This will throw a timeout error if any of the iterator's `next()` calls takes more than 100ms, but\n   *  // will continue to iterate successfully otherwise, regardless of the number of batches.\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * const cursor = collection.find({}, { timeoutMS: 1000, timeoutMode: 'cursorLifetime' });\n   * const docs = await cursor.toArray(); // This entire line will throw a timeout error if all batches are not fetched and returned within 1000ms.\n   * ```\n   */\n  timeoutMode?: CursorTimeoutMode;\n\n  /**\n   * @internal\n   *\n   * A timeout context to govern the total time the cursor can live.  If provided, the cursor\n   * cannot be used in ITERATION mode.\n   */\n  timeoutContext?: CursorTimeoutContext;\n}\n\n/** @internal */\nexport type InternalAbstractCursorOptions = Omit<AbstractCursorOptions, 'readPreference'> & {\n  // resolved\n  readPreference: ReadPreference;\n  readConcern?: ReadConcern;\n\n  // cursor flags, some are deprecated\n  oplogReplay?: boolean;\n  exhaust?: boolean;\n  partial?: boolean;\n\n  omitMaxTimeMS?: boolean;\n};\n\n/** @public */\nexport type AbstractCursorEvents = {\n  [AbstractCursor.CLOSE](): void;\n};\n\n/** @public */\nexport abstract class AbstractCursor<\n    TSchema = any,\n    CursorEvents extends AbstractCursorEvents = AbstractCursorEvents\n  >\n  extends TypedEventEmitter<CursorEvents>\n  implements AsyncDisposable\n{\n  /** @internal */\n  private cursorId: Long | null;\n  /** @internal */\n  private cursorSession: ClientSession;\n  /** @internal */\n  private selectedServer?: Server;\n  /** @internal */\n  private cursorNamespace: MongoDBNamespace;\n  /** @internal */\n  private documents: CursorResponse | null = null;\n  /** @internal */\n  private cursorClient: MongoClient;\n  /** @internal */\n  private transform?: (doc: TSchema) => any;\n  /**\n   * @internal\n   * This is true whether or not the first command fails. It only indicates whether or not the first\n   * command has been run.\n   */\n  private initialized: boolean;\n  /** @internal */\n  private isClosed: boolean;\n  /** @internal */\n  private isKilled: boolean;\n  /** @internal */\n  protected readonly cursorOptions: InternalAbstractCursorOptions;\n  /** @internal */\n  protected timeoutContext?: CursorTimeoutContext;\n\n  /** @event */\n  static readonly CLOSE = 'close' as const;\n\n  /** @internal */\n  protected deserializationOptions: OnDemandDocumentDeserializeOptions;\n  protected signal: AbortSignal | undefined;\n  private abortListener: Disposable | undefined;\n\n  /** @internal */\n  protected constructor(\n    client: MongoClient,\n    namespace: MongoDBNamespace,\n    options: AbstractCursorOptions & Abortable = {}\n  ) {\n    super();\n    this.on('error', noop);\n\n    if (!client.s.isMongoClient) {\n      throw new MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n    this.cursorClient = client;\n    this.cursorNamespace = namespace;\n    this.cursorId = null;\n    this.initialized = false;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.cursorOptions = {\n      readPreference:\n        options.readPreference && options.readPreference instanceof ReadPreference\n          ? options.readPreference\n          : ReadPreference.primary,\n      ...pluckBSONSerializeOptions(options),\n      timeoutMS: options?.timeoutContext?.csotEnabled()\n        ? options.timeoutContext.timeoutMS\n        : options.timeoutMS,\n      tailable: options.tailable,\n      awaitData: options.awaitData\n    };\n\n    if (this.cursorOptions.timeoutMS != null) {\n      if (options.timeoutMode == null) {\n        if (options.tailable) {\n          if (options.awaitData) {\n            if (\n              options.maxAwaitTimeMS != null &&\n              options.maxAwaitTimeMS >= this.cursorOptions.timeoutMS\n            )\n              throw new MongoInvalidArgumentError(\n                'Cannot specify maxAwaitTimeMS >= timeoutMS for a tailable awaitData cursor'\n              );\n          }\n\n          this.cursorOptions.timeoutMode = CursorTimeoutMode.ITERATION;\n        } else {\n          this.cursorOptions.timeoutMode = CursorTimeoutMode.LIFETIME;\n        }\n      } else {\n        if (options.tailable && options.timeoutMode === CursorTimeoutMode.LIFETIME) {\n          throw new MongoInvalidArgumentError(\n            \"Cannot set tailable cursor's timeoutMode to LIFETIME\"\n          );\n        }\n        this.cursorOptions.timeoutMode = options.timeoutMode;\n      }\n    } else {\n      if (options.timeoutMode != null)\n        throw new MongoInvalidArgumentError('Cannot set timeoutMode without setting timeoutMS');\n    }\n\n    // Set for initial command\n    this.cursorOptions.omitMaxTimeMS =\n      this.cursorOptions.timeoutMS != null &&\n      ((this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION &&\n        !this.cursorOptions.tailable) ||\n        (this.cursorOptions.tailable && !this.cursorOptions.awaitData));\n\n    const readConcern = ReadConcern.fromOptions(options);\n    if (readConcern) {\n      this.cursorOptions.readConcern = readConcern;\n    }\n\n    if (typeof options.batchSize === 'number') {\n      this.cursorOptions.batchSize = options.batchSize;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      this.cursorOptions.comment = options.comment;\n    }\n\n    if (typeof options.maxTimeMS === 'number') {\n      this.cursorOptions.maxTimeMS = options.maxTimeMS;\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      this.cursorOptions.maxAwaitTimeMS = options.maxAwaitTimeMS;\n    }\n\n    if (options.session instanceof ClientSession) {\n      this.cursorSession = options.session;\n    } else {\n      this.cursorSession = this.cursorClient.startSession({ owner: this, explicit: false });\n    }\n\n    this.deserializationOptions = {\n      ...this.cursorOptions,\n      validation: {\n        utf8: options?.enableUtf8Validation === false ? false : true\n      }\n    };\n\n    this.timeoutContext = options.timeoutContext;\n    this.signal = options.signal;\n    this.abortListener = addAbortListener(\n      this.signal,\n      () => void this.close().then(undefined, squashError)\n    );\n    this.trackCursor();\n  }\n\n  /**\n   * The cursor has no id until it receives a response from the initial cursor creating command.\n   *\n   * It is non-zero for as long as the database has an open cursor.\n   *\n   * The initiating command may receive a zero id if the entire result is in the `firstBatch`.\n   */\n  get id(): Long | undefined {\n    return this.cursorId ?? undefined;\n  }\n\n  /** @internal */\n  get isDead() {\n    return (this.cursorId?.isZero() ?? false) || this.isClosed || this.isKilled;\n  }\n\n  /** @internal */\n  get client(): MongoClient {\n    return this.cursorClient;\n  }\n\n  /** @internal */\n  get server(): Server | undefined {\n    return this.selectedServer;\n  }\n\n  get namespace(): MongoDBNamespace {\n    return this.cursorNamespace;\n  }\n\n  get readPreference(): ReadPreference {\n    return this.cursorOptions.readPreference;\n  }\n\n  get readConcern(): ReadConcern | undefined {\n    return this.cursorOptions.readConcern;\n  }\n\n  /** @internal */\n  get session(): ClientSession {\n    return this.cursorSession;\n  }\n\n  set session(clientSession: ClientSession) {\n    this.cursorSession = clientSession;\n  }\n\n  /**\n   * The cursor is closed and all remaining locally buffered documents have been iterated.\n   */\n  get closed(): boolean {\n    return this.isClosed && (this.documents?.length ?? 0) === 0;\n  }\n\n  /**\n   * A `killCursors` command was attempted on this cursor.\n   * This is performed if the cursor id is non zero.\n   */\n  get killed(): boolean {\n    return this.isKilled;\n  }\n\n  get loadBalanced(): boolean {\n    return !!this.cursorClient.topology?.loadBalanced;\n  }\n\n  /**\n   * @beta\n   * @experimental\n   * An alias for {@link AbstractCursor.close|AbstractCursor.close()}.\n   */\n  declare [Symbol.asyncDispose]: () => Promise<void>;\n  /** @internal */\n  async asyncDispose() {\n    await this.close();\n  }\n\n  /** Adds cursor to client's tracking so it will be closed by MongoClient.close() */\n  private trackCursor() {\n    this.cursorClient.s.activeCursors.add(this);\n    if (!this.listeners('close').includes(removeActiveCursor)) {\n      this.once('close', removeActiveCursor);\n    }\n  }\n\n  /** Returns current buffered documents length */\n  bufferedCount(): number {\n    return this.documents?.length ?? 0;\n  }\n\n  /** Returns current buffered documents */\n  readBufferedDocuments(number?: number): NonNullable<TSchema>[] {\n    const bufferedDocs: NonNullable<TSchema>[] = [];\n    const documentsToRead = Math.min(\n      number ?? this.documents?.length ?? 0,\n      this.documents?.length ?? 0\n    );\n\n    for (let count = 0; count < documentsToRead; count++) {\n      const document = this.documents?.shift(this.deserializationOptions);\n      if (document != null) {\n        bufferedDocs.push(document);\n      }\n    }\n\n    return bufferedDocs;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<TSchema, void, void> {\n    this.signal?.throwIfAborted();\n\n    if (this.closed) {\n      return;\n    }\n\n    try {\n      while (true) {\n        if (this.isKilled) {\n          return;\n        }\n\n        if (this.closed) {\n          return;\n        }\n\n        if (this.cursorId != null && this.isDead && (this.documents?.length ?? 0) === 0) {\n          return;\n        }\n\n        const document = await this.next();\n\n        // eslint-disable-next-line no-restricted-syntax\n        if (document === null) {\n          return;\n        }\n\n        yield document;\n\n        this.signal?.throwIfAborted();\n      }\n    } finally {\n      // Only close the cursor if it has not already been closed. This finally clause handles\n      // the case when a user would break out of a for await of loop early.\n      if (!this.isClosed) {\n        try {\n          await this.close();\n        } catch (error) {\n          squashError(error);\n        }\n      }\n    }\n  }\n\n  stream(options?: CursorStreamOptions): Readable & AsyncIterable<TSchema> {\n    const readable = new ReadableCursorStream(this);\n    const abortListener = addAbortListener(this.signal, function () {\n      readable.destroy(this.reason);\n    });\n    readable.once('end', () => {\n      abortListener?.[kDispose]();\n    });\n\n    if (options?.transform) {\n      const transform = options.transform;\n\n      const transformedStream = readable.pipe(\n        new Transform({\n          objectMode: true,\n          highWaterMark: 1,\n          transform(chunk, _, callback) {\n            try {\n              const transformed = transform(chunk);\n              callback(undefined, transformed);\n            } catch (err) {\n              callback(err);\n            }\n          }\n        })\n      );\n\n      // Bubble errors to transformed stream, because otherwise no way\n      // to handle this error.\n      readable.on('error', err => transformedStream.emit('error', err));\n\n      return transformedStream;\n    }\n\n    return readable;\n  }\n\n  async hasNext(): Promise<boolean> {\n    this.signal?.throwIfAborted();\n\n    if (this.cursorId === Long.ZERO) {\n      return false;\n    }\n\n    if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n    try {\n      do {\n        if ((this.documents?.length ?? 0) !== 0) {\n          return true;\n        }\n        await this.fetchBatch();\n      } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n    } finally {\n      if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n\n    return false;\n  }\n\n  /** Get the next available document from the cursor, returns null if no more documents are available. */\n  async next(): Promise<TSchema | null> {\n    this.signal?.throwIfAborted();\n\n    if (this.cursorId === Long.ZERO) {\n      throw new MongoCursorExhaustedError();\n    }\n\n    if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n\n    try {\n      do {\n        const doc = this.documents?.shift(this.deserializationOptions);\n        if (doc != null) {\n          if (this.transform != null) return await this.transformDocument(doc);\n          return doc;\n        }\n        await this.fetchBatch();\n      } while (!this.isDead || (this.documents?.length ?? 0) !== 0);\n    } finally {\n      if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Try to get the next available document from the cursor or `null` if an empty batch is returned\n   */\n  async tryNext(): Promise<TSchema | null> {\n    this.signal?.throwIfAborted();\n\n    if (this.cursorId === Long.ZERO) {\n      throw new MongoCursorExhaustedError();\n    }\n\n    if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION && this.cursorId != null) {\n      this.timeoutContext?.refresh();\n    }\n    try {\n      let doc = this.documents?.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n\n      await this.fetchBatch();\n\n      doc = this.documents?.shift(this.deserializationOptions);\n      if (doc != null) {\n        if (this.transform != null) return await this.transformDocument(doc);\n        return doc;\n      }\n    } finally {\n      if (this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION) {\n        this.timeoutContext?.clear();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Iterates over all the documents for this cursor using the iterator, callback pattern.\n   *\n   * If the iterator returns `false`, iteration will stop.\n   *\n   * @param iterator - The iteration callback.\n   * @deprecated - Will be removed in a future release. Use for await...of instead.\n   */\n  async forEach(iterator: (doc: TSchema) => boolean | void): Promise<void> {\n    this.signal?.throwIfAborted();\n\n    if (typeof iterator !== 'function') {\n      throw new MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n    for await (const document of this) {\n      const result = iterator(document);\n      if (result === false) {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Frees any client-side resources used by the cursor.\n   */\n  async close(options?: { timeoutMS?: number }): Promise<void> {\n    await this.cleanup(options?.timeoutMS);\n  }\n\n  /**\n   * Returns an array of documents. The caller is responsible for making sure that there\n   * is enough memory to store the results. Note that the array only contains partial\n   * results when this cursor had been previously accessed. In that case,\n   * cursor.rewind() can be used to reset the cursor.\n   */\n  async toArray(): Promise<TSchema[]> {\n    this.signal?.throwIfAborted();\n\n    const array: TSchema[] = [];\n    // at the end of the loop (since readBufferedDocuments is called) the buffer will be empty\n    // then, the 'await of' syntax will run a getMore call\n    for await (const document of this) {\n      array.push(document);\n      const docs = this.readBufferedDocuments();\n      if (this.transform != null) {\n        for (const doc of docs) {\n          array.push(await this.transformDocument(doc));\n        }\n      } else {\n        array.push(...docs);\n      }\n    }\n    return array;\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n  addCursorFlag(flag: CursorFlag, value: boolean): this {\n    this.throwIfInitialized();\n    if (!CURSOR_FLAGS.includes(flag)) {\n      throw new MongoInvalidArgumentError(`Flag ${flag} is not one of ${CURSOR_FLAGS}`);\n    }\n\n    if (typeof value !== 'boolean') {\n      throw new MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n\n    this.cursorOptions[flag] = value;\n    return this;\n  }\n\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   *\n   * **Note** Cursors use `null` internally to indicate that there are no more documents in the cursor. Providing a mapping\n   * function that maps values to `null` will result in the cursor closing itself before it has finished iterating\n   * all documents.  This will **not** result in a memory leak, just surprising behavior.  For example:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => null);\n   *\n   * const documents = await cursor.toArray();\n   * // documents is always [], regardless of how many documents are in the collection.\n   * ```\n   *\n   * Other falsey values are allowed:\n   *\n   * ```typescript\n   * const cursor = collection.find({});\n   * cursor.map(() => '');\n   *\n   * const documents = await cursor.toArray();\n   * // documents is now an array of empty strings\n   * ```\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n  map<T = any>(transform: (doc: TSchema) => T): AbstractCursor<T> {\n    this.throwIfInitialized();\n    const oldTransform = this.transform;\n    if (oldTransform) {\n      this.transform = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this.transform = transform;\n    }\n\n    return this as unknown as AbstractCursor<T>;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadPreference(readPreference: ReadPreferenceLike): this {\n    this.throwIfInitialized();\n    if (readPreference instanceof ReadPreference) {\n      this.cursorOptions.readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this.cursorOptions.readPreference = ReadPreference.fromString(readPreference);\n    } else {\n      throw new MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n\n    return this;\n  }\n\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n  withReadConcern(readConcern: ReadConcernLike): this {\n    this.throwIfInitialized();\n    const resolvedReadConcern = ReadConcern.fromOptions({ readConcern });\n    if (resolvedReadConcern) {\n      this.cursorOptions.readConcern = resolvedReadConcern;\n    }\n\n    return this;\n  }\n\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n  maxTimeMS(value: number): this {\n    this.throwIfInitialized();\n    if (typeof value !== 'number') {\n      throw new MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n\n    this.cursorOptions.maxTimeMS = value;\n    return this;\n  }\n\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://www.mongodb.com/docs/manual/reference/command/find/|find command documentation}.\n   */\n  batchSize(value: number): this {\n    this.throwIfInitialized();\n    if (this.cursorOptions.tailable) {\n      throw new MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n\n    if (typeof value !== 'number') {\n      throw new MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n\n    this.cursorOptions.batchSize = value;\n    return this;\n  }\n\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n  rewind(): void {\n    if (this.timeoutContext && this.timeoutContext.owner !== this) {\n      throw new MongoAPIError(`Cannot rewind cursor that does not own its timeout context.`);\n    }\n    if (!this.initialized) {\n      return;\n    }\n\n    this.cursorId = null;\n    this.documents?.clear();\n    this.timeoutContext?.clear();\n    this.timeoutContext = undefined;\n    this.isClosed = false;\n    this.isKilled = false;\n    this.initialized = false;\n    this.hasEmittedClose = false;\n    this.trackCursor();\n\n    // We only want to end this session if we created it, and it hasn't ended yet\n    if (this.cursorSession.explicit === false) {\n      if (!this.cursorSession.hasEnded) {\n        this.cursorSession.endSession().then(undefined, squashError);\n      }\n      this.cursorSession = this.cursorClient.startSession({ owner: this, explicit: false });\n    }\n  }\n\n  /**\n   * Returns a new uninitialized copy of this cursor, with options matching those that have been set on the current instance\n   */\n  abstract clone(): AbstractCursor<TSchema>;\n\n  /** @internal */\n  protected abstract _initialize(\n    session: ClientSession | undefined\n  ): Promise<InitialCursorResponse>;\n\n  /** @internal */\n  async getMore(batchSize: number): Promise<CursorResponse> {\n    if (this.cursorId == null) {\n      throw new MongoRuntimeError(\n        'Unexpected null cursor id. A cursor creating command should have set this'\n      );\n    }\n    if (this.selectedServer == null) {\n      throw new MongoRuntimeError(\n        'Unexpected null selectedServer. A cursor creating command should have set this'\n      );\n    }\n    const getMoreOptions = {\n      ...this.cursorOptions,\n      session: this.cursorSession,\n      batchSize\n    };\n\n    const getMoreOperation = new GetMoreOperation(\n      this.cursorNamespace,\n      this.cursorId,\n      this.selectedServer,\n      getMoreOptions\n    );\n\n    return await executeOperation(this.cursorClient, getMoreOperation, this.timeoutContext);\n  }\n\n  /**\n   * @internal\n   *\n   * This function is exposed for the unified test runner's createChangeStream\n   * operation.  We cannot refactor to use the abstract _initialize method without\n   * a significant refactor.\n   */\n  private async cursorInit(): Promise<void> {\n    if (this.cursorOptions.timeoutMS != null) {\n      this.timeoutContext ??= new CursorTimeoutContext(\n        TimeoutContext.create({\n          serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,\n          timeoutMS: this.cursorOptions.timeoutMS\n        }),\n        this\n      );\n    }\n    try {\n      const state = await this._initialize(this.cursorSession);\n      // Set omitMaxTimeMS to the value needed for subsequent getMore calls\n      this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null;\n      const response = state.response;\n      this.selectedServer = state.server;\n      this.cursorId = response.id;\n      this.cursorNamespace = response.ns ?? this.namespace;\n      this.documents = response;\n      this.initialized = true; // the cursor is now initialized, even if it is dead\n    } catch (error) {\n      // the cursor is now initialized, even if an error occurred\n      this.initialized = true;\n      await this.cleanup(undefined, error);\n      throw error;\n    }\n\n    if (this.isDead) {\n      await this.cleanup();\n    }\n\n    return;\n  }\n\n  /** @internal Attempt to obtain more documents */\n  private async fetchBatch(): Promise<void> {\n    if (this.isClosed) {\n      return;\n    }\n\n    if (this.isDead) {\n      // if the cursor is dead, we clean it up\n      // cleanupCursor should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n      return;\n    }\n\n    if (this.cursorId == null) {\n      await this.cursorInit();\n      // If the cursor died or returned documents, return\n      if ((this.documents?.length ?? 0) !== 0 || this.isDead) return;\n      // Otherwise, run a getMore\n    }\n\n    // otherwise need to call getMore\n    const batchSize = this.cursorOptions.batchSize || 1000;\n\n    try {\n      const response = await this.getMore(batchSize);\n      this.cursorId = response.id;\n      this.documents = response;\n    } catch (error) {\n      try {\n        await this.cleanup(undefined, error);\n      } catch (cleanupError) {\n        // `cleanupCursor` should never throw, squash and throw the original error\n        squashError(cleanupError);\n      }\n      throw error;\n    }\n\n    if (this.isDead) {\n      // If we successfully received a response from a cursor BUT the cursor indicates that it is exhausted,\n      // we intentionally clean up the cursor to release its session back into the pool before the cursor\n      // is iterated.  This prevents a cursor that is exhausted on the server from holding\n      // onto a session indefinitely until the AbstractCursor is iterated.\n      //\n      // cleanupCursorAsync should never throw, but if it does it indicates a bug in the driver\n      // and we should surface the error\n      await this.cleanup();\n    }\n  }\n\n  /** @internal */\n  private async cleanup(timeoutMS?: number, error?: Error) {\n    this.abortListener?.[kDispose]();\n    this.isClosed = true;\n    const timeoutContextForKillCursors = (): CursorTimeoutContext | undefined => {\n      if (timeoutMS != null) {\n        this.timeoutContext?.clear();\n        return new CursorTimeoutContext(\n          TimeoutContext.create({\n            serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,\n            timeoutMS\n          }),\n          this\n        );\n      } else {\n        return this.timeoutContext?.refreshed();\n      }\n    };\n    try {\n      if (\n        !this.isKilled &&\n        this.cursorId &&\n        !this.cursorId.isZero() &&\n        this.cursorNamespace &&\n        this.selectedServer &&\n        !this.cursorSession.hasEnded\n      ) {\n        this.isKilled = true;\n        const cursorId = this.cursorId;\n        this.cursorId = Long.ZERO;\n\n        await executeOperation(\n          this.cursorClient,\n          new KillCursorsOperation(cursorId, this.cursorNamespace, this.selectedServer, {\n            session: this.cursorSession\n          }),\n          timeoutContextForKillCursors()\n        );\n      }\n    } catch (error) {\n      squashError(error);\n    } finally {\n      try {\n        if (this.cursorSession?.owner === this) {\n          await this.cursorSession.endSession({ error });\n        }\n        if (!this.cursorSession?.inTransaction()) {\n          maybeClearPinnedConnection(this.cursorSession, { error });\n        }\n      } finally {\n        this.emitClose();\n      }\n    }\n  }\n\n  /** @internal */\n  private hasEmittedClose = false;\n  /** @internal */\n  private emitClose() {\n    try {\n      if (!this.hasEmittedClose && ((this.documents?.length ?? 0) === 0 || this.isClosed)) {\n        // @ts-expect-error: CursorEvents is generic so Parameters<CursorEvents[\"close\"]> may not be assignable to `[]`. Not sure how to require extenders do not add parameters.\n        this.emit('close');\n      }\n    } finally {\n      this.hasEmittedClose = true;\n    }\n  }\n\n  /** @internal */\n  private async transformDocument(document: NonNullable<TSchema>): Promise<NonNullable<TSchema>> {\n    if (this.transform == null) return document;\n\n    try {\n      const transformedDocument = this.transform(document);\n      // eslint-disable-next-line no-restricted-syntax\n      if (transformedDocument === null) {\n        const TRANSFORM_TO_NULL_ERROR =\n          'Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.';\n        throw new MongoAPIError(TRANSFORM_TO_NULL_ERROR);\n      }\n      return transformedDocument;\n    } catch (transformError) {\n      try {\n        await this.close();\n      } catch (closeError) {\n        squashError(closeError);\n      }\n      throw transformError;\n    }\n  }\n\n  /** @internal */\n  protected throwIfInitialized() {\n    if (this.initialized) throw new MongoCursorInUseError();\n  }\n}\n\nclass ReadableCursorStream extends Readable {\n  private _cursor: AbstractCursor;\n  private _readInProgress = false;\n\n  constructor(cursor: AbstractCursor) {\n    super({\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    });\n    this._cursor = cursor;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  override _read(size: number): void {\n    if (!this._readInProgress) {\n      this._readInProgress = true;\n      this._readNext();\n    }\n  }\n\n  override _destroy(error: Error | null, callback: (error?: Error | null) => void): void {\n    this._cursor.close().then(\n      () => callback(error),\n      closeError => callback(closeError)\n    );\n  }\n\n  private _readNext() {\n    if (this._cursor.id === Long.ZERO) {\n      this.push(null);\n      return;\n    }\n\n    this._cursor.next().then(\n      result => {\n        if (result == null) {\n          this.push(null);\n        } else if (this.destroyed) {\n          this._cursor.close().then(undefined, squashError);\n        } else {\n          if (this.push(result)) {\n            return this._readNext();\n          }\n\n          this._readInProgress = false;\n        }\n      },\n      err => {\n        // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n        //       desired behavior is that a stream ends cleanly when a user explicitly closes\n        //       a client during iteration. Alternatively, we could do the \"right\" thing and\n        //       propagate the error message by removing this special case.\n        if (err.message.match(/server is closed/)) {\n          this._cursor.close().then(undefined, squashError);\n          return this.push(null);\n        }\n\n        // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n        //       to be \"operation was interrupted\", where a cursor has been closed but there is an\n        //       active getMore in-flight. This used to check if the cursor was killed but once\n        //       that changed to happen in cleanup legitimate errors would not destroy the\n        //       stream. There are change streams test specifically test these cases.\n        if (err.message.match(/operation was interrupted/)) {\n          return this.push(null);\n        }\n\n        // NOTE: The two above checks on the message of the error will cause a null to be pushed\n        //       to the stream, thus closing the stream before the destroy call happens. This means\n        //       that either of those error messages on a change stream will not get a proper\n        //       'error' event to be emitted (the error passed to destroy). Change stream resumability\n        //       relies on that error event to be emitted to create its new cursor and thus was not\n        //       working on 4.4 servers because the error emitted on failover was \"interrupted at\n        //       shutdown\" while on 5.0+ it is \"The server is in quiesce mode and will shut down\".\n        //       See NODE-4475.\n        return this.destroy(err);\n      }\n    );\n  }\n}\n\nconfigureResourceManagement(AbstractCursor.prototype);\n\n/**\n * @internal\n * The cursor timeout context is a wrapper around a timeout context\n * that keeps track of the \"owner\" of the cursor.  For timeout contexts\n * instantiated inside a cursor, the owner will be the cursor.\n *\n * All timeout behavior is exactly the same as the wrapped timeout context's.\n */\nexport class CursorTimeoutContext extends TimeoutContext {\n  constructor(\n    public timeoutContext: TimeoutContext,\n    public owner: symbol | AbstractCursor\n  ) {\n    super();\n  }\n  override get serverSelectionTimeout(): Timeout | null {\n    return this.timeoutContext.serverSelectionTimeout;\n  }\n  override get connectionCheckoutTimeout(): Timeout | null {\n    return this.timeoutContext.connectionCheckoutTimeout;\n  }\n  override get clearServerSelectionTimeout(): boolean {\n    return this.timeoutContext.clearServerSelectionTimeout;\n  }\n  override get timeoutForSocketWrite(): Timeout | null {\n    return this.timeoutContext.timeoutForSocketWrite;\n  }\n  override get timeoutForSocketRead(): Timeout | null {\n    return this.timeoutContext.timeoutForSocketRead;\n  }\n  override csotEnabled(): this is CSOTTimeoutContext {\n    return this.timeoutContext.csotEnabled();\n  }\n  override refresh(): void {\n    if (typeof this.owner !== 'symbol') return this.timeoutContext.refresh();\n  }\n  override clear(): void {\n    if (typeof this.owner !== 'symbol') return this.timeoutContext.clear();\n  }\n  override get maxTimeMS(): number | null {\n    return this.timeoutContext.maxTimeMS;\n  }\n  get timeoutMS(): number | null {\n    return this.timeoutContext.csotEnabled() ? this.timeoutContext.timeoutMS : null;\n  }\n  override refreshed(): CursorTimeoutContext {\n    return new CursorTimeoutContext(this.timeoutContext.refreshed(), this.owner);\n  }\n  override addMaxTimeMSToCommand(command: Document, options: { omitMaxTimeMS?: boolean }): void {\n    this.timeoutContext.addMaxTimeMSToCommand(command, options);\n  }\n  override getSocketTimeoutMS(): number | undefined {\n    return this.timeoutContext.getSocketTimeoutMS();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}