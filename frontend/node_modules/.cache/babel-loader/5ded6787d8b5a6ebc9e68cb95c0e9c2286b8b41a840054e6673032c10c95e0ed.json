{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggregationCursor = void 0;\nconst error_1 = require(\"../error\");\nconst explain_1 = require(\"../explain\");\nconst aggregate_1 = require(\"../operations/aggregate\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst utils_1 = require(\"../utils\");\nconst abstract_cursor_1 = require(\"./abstract_cursor\");\n/**\n * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query. It supports\n * one by one document iteration, conversion to an array or can be iterated as a Node 4.X\n * or higher stream\n * @public\n */\nclass AggregationCursor extends explain_1.ExplainableCursor {\n  /** @internal */\n  constructor(client, namespace, pipeline = [], options = {}) {\n    super(client, namespace, options);\n    this.pipeline = pipeline;\n    this.aggregateOptions = options;\n    const lastStage = this.pipeline[this.pipeline.length - 1];\n    if (this.cursorOptions.timeoutMS != null && this.cursorOptions.timeoutMode === abstract_cursor_1.CursorTimeoutMode.ITERATION && (lastStage?.$merge != null || lastStage?.$out != null)) throw new error_1.MongoAPIError('Cannot use $out or $merge stage with ITERATION timeoutMode');\n  }\n  clone() {\n    const clonedOptions = (0, utils_1.mergeOptions)({}, this.aggregateOptions);\n    delete clonedOptions.session;\n    return new AggregationCursor(this.client, this.namespace, this.pipeline, {\n      ...clonedOptions\n    });\n  }\n  map(transform) {\n    return super.map(transform);\n  }\n  /** @internal */\n  async _initialize(session) {\n    const options = {\n      ...this.aggregateOptions,\n      ...this.cursorOptions,\n      session,\n      signal: this.signal\n    };\n    if (options.explain) {\n      try {\n        (0, explain_1.validateExplainTimeoutOptions)(options, explain_1.Explain.fromOptions(options));\n      } catch {\n        throw new error_1.MongoAPIError('timeoutMS cannot be used with explain when explain is specified in aggregateOptions');\n      }\n    }\n    const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, options);\n    const response = await (0, execute_operation_1.executeOperation)(this.client, aggregateOperation, this.timeoutContext);\n    return {\n      server: aggregateOperation.server,\n      session,\n      response\n    };\n  }\n  async explain(verbosity, options) {\n    const {\n      explain,\n      timeout\n    } = this.resolveExplainTimeoutOptions(verbosity, options);\n    return (await (0, execute_operation_1.executeOperation)(this.client, new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {\n      ...this.aggregateOptions,\n      // NOTE: order matters here, we may need to refine this\n      ...this.cursorOptions,\n      ...timeout,\n      explain: explain ?? true\n    }))).shift(this.deserializationOptions);\n  }\n  addStage(stage) {\n    this.throwIfInitialized();\n    if (this.cursorOptions.timeoutMS != null && this.cursorOptions.timeoutMode === abstract_cursor_1.CursorTimeoutMode.ITERATION && (stage.$out != null || stage.$merge != null)) {\n      throw new error_1.MongoAPIError('Cannot use $out or $merge stage with ITERATION timeoutMode');\n    }\n    this.pipeline.push(stage);\n    return this;\n  }\n  group($group) {\n    return this.addStage({\n      $group\n    });\n  }\n  /** Add a limit stage to the aggregation pipeline */\n  limit($limit) {\n    return this.addStage({\n      $limit\n    });\n  }\n  /** Add a match stage to the aggregation pipeline */\n  match($match) {\n    return this.addStage({\n      $match\n    });\n  }\n  /** Add an out stage to the aggregation pipeline */\n  out($out) {\n    return this.addStage({\n      $out\n    });\n  }\n  /**\n   * Add a project stage to the aggregation pipeline\n   *\n   * @remarks\n   * In order to strictly type this function you must provide an interface\n   * that represents the effect of your projection on the result documents.\n   *\n   * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.\n   * You should specify a parameterized type to have assertions on your final results.\n   *\n   * @example\n   * ```typescript\n   * // Best way\n   * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });\n   * // Flexible way\n   * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });\n   * ```\n   *\n   * @remarks\n   * In order to strictly type this function you must provide an interface\n   * that represents the effect of your projection on the result documents.\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling project,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);\n   * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });\n   * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();\n   *\n   * // or always use chaining and save the final cursor\n   *\n   * const cursor = coll.aggregate().project<{ a: string }>({\n   *   _id: 0,\n   *   a: { $convert: { input: '$a', to: 'string' }\n   * }});\n   * ```\n   */\n  project($project) {\n    return this.addStage({\n      $project\n    });\n  }\n  /** Add a lookup stage to the aggregation pipeline */\n  lookup($lookup) {\n    return this.addStage({\n      $lookup\n    });\n  }\n  /** Add a redact stage to the aggregation pipeline */\n  redact($redact) {\n    return this.addStage({\n      $redact\n    });\n  }\n  /** Add a skip stage to the aggregation pipeline */\n  skip($skip) {\n    return this.addStage({\n      $skip\n    });\n  }\n  /** Add a sort stage to the aggregation pipeline */\n  sort($sort) {\n    return this.addStage({\n      $sort\n    });\n  }\n  /** Add a unwind stage to the aggregation pipeline */\n  unwind($unwind) {\n    return this.addStage({\n      $unwind\n    });\n  }\n  /** Add a geoNear stage to the aggregation pipeline */\n  geoNear($geoNear) {\n    return this.addStage({\n      $geoNear\n    });\n  }\n}\nexports.AggregationCursor = AggregationCursor;","map":{"version":3,"names":["error_1","require","explain_1","aggregate_1","execute_operation_1","utils_1","abstract_cursor_1","AggregationCursor","ExplainableCursor","constructor","client","namespace","pipeline","options","aggregateOptions","lastStage","length","cursorOptions","timeoutMS","timeoutMode","CursorTimeoutMode","ITERATION","$merge","$out","MongoAPIError","clone","clonedOptions","mergeOptions","session","map","transform","_initialize","signal","explain","validateExplainTimeoutOptions","Explain","fromOptions","aggregateOperation","AggregateOperation","response","executeOperation","timeoutContext","server","verbosity","timeout","resolveExplainTimeoutOptions","shift","deserializationOptions","addStage","stage","throwIfInitialized","push","group","$group","limit","$limit","match","$match","out","project","$project","lookup","$lookup","redact","$redact","skip","$skip","sort","$sort","unwind","$unwind","geoNear","$geoNear","exports"],"sources":["C:\\Users\\HP\\node_modules\\mongodb\\src\\cursor\\aggregation_cursor.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport { MongoAPIError } from '../error';\nimport {\n  Explain,\n  ExplainableCursor,\n  type ExplainCommandOptions,\n  type ExplainVerbosityLike,\n  validateExplainTimeoutOptions\n} from '../explain';\nimport type { MongoClient } from '../mongo_client';\nimport { type Abortable } from '../mongo_types';\nimport { AggregateOperation, type AggregateOptions } from '../operations/aggregate';\nimport { executeOperation } from '../operations/execute_operation';\nimport type { ClientSession } from '../sessions';\nimport type { Sort } from '../sort';\nimport { mergeOptions, type MongoDBNamespace } from '../utils';\nimport {\n  type AbstractCursorOptions,\n  CursorTimeoutMode,\n  type InitialCursorResponse\n} from './abstract_cursor';\n\n/** @public */\nexport interface AggregationCursorOptions extends AbstractCursorOptions, AggregateOptions {}\n\n/**\n * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query. It supports\n * one by one document iteration, conversion to an array or can be iterated as a Node 4.X\n * or higher stream\n * @public\n */\nexport class AggregationCursor<TSchema = any> extends ExplainableCursor<TSchema> {\n  public readonly pipeline: Document[];\n  /** @internal */\n  private aggregateOptions: AggregateOptions & Abortable;\n\n  /** @internal */\n  constructor(\n    client: MongoClient,\n    namespace: MongoDBNamespace,\n    pipeline: Document[] = [],\n    options: AggregateOptions & Abortable = {}\n  ) {\n    super(client, namespace, options);\n\n    this.pipeline = pipeline;\n    this.aggregateOptions = options;\n\n    const lastStage: Document | undefined = this.pipeline[this.pipeline.length - 1];\n\n    if (\n      this.cursorOptions.timeoutMS != null &&\n      this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION &&\n      (lastStage?.$merge != null || lastStage?.$out != null)\n    )\n      throw new MongoAPIError('Cannot use $out or $merge stage with ITERATION timeoutMode');\n  }\n\n  clone(): AggregationCursor<TSchema> {\n    const clonedOptions = mergeOptions({}, this.aggregateOptions);\n    delete clonedOptions.session;\n    return new AggregationCursor(this.client, this.namespace, this.pipeline, {\n      ...clonedOptions\n    });\n  }\n\n  override map<T>(transform: (doc: TSchema) => T): AggregationCursor<T> {\n    return super.map(transform) as AggregationCursor<T>;\n  }\n\n  /** @internal */\n  async _initialize(session: ClientSession): Promise<InitialCursorResponse> {\n    const options = {\n      ...this.aggregateOptions,\n      ...this.cursorOptions,\n      session,\n      signal: this.signal\n    };\n    if (options.explain) {\n      try {\n        validateExplainTimeoutOptions(options, Explain.fromOptions(options));\n      } catch {\n        throw new MongoAPIError(\n          'timeoutMS cannot be used with explain when explain is specified in aggregateOptions'\n        );\n      }\n    }\n\n    const aggregateOperation = new AggregateOperation(this.namespace, this.pipeline, options);\n\n    const response = await executeOperation(this.client, aggregateOperation, this.timeoutContext);\n\n    return { server: aggregateOperation.server, session, response };\n  }\n\n  /** Execute the explain for the cursor */\n  async explain(): Promise<Document>;\n  async explain(verbosity: ExplainVerbosityLike | ExplainCommandOptions): Promise<Document>;\n  async explain(options: { timeoutMS?: number }): Promise<Document>;\n  async explain(\n    verbosity: ExplainVerbosityLike | ExplainCommandOptions,\n    options: { timeoutMS?: number }\n  ): Promise<Document>;\n  async explain(\n    verbosity?: ExplainVerbosityLike | ExplainCommandOptions | { timeoutMS?: number },\n    options?: { timeoutMS?: number }\n  ): Promise<Document> {\n    const { explain, timeout } = this.resolveExplainTimeoutOptions(verbosity, options);\n    return (\n      await executeOperation(\n        this.client,\n        new AggregateOperation(this.namespace, this.pipeline, {\n          ...this.aggregateOptions, // NOTE: order matters here, we may need to refine this\n          ...this.cursorOptions,\n          ...timeout,\n          explain: explain ?? true\n        })\n      )\n    ).shift(this.deserializationOptions);\n  }\n\n  /** Add a stage to the aggregation pipeline\n   * @example\n   * ```\n   * const documents = await users.aggregate().addStage({ $match: { name: /Mike/ } }).toArray();\n   * ```\n   * @example\n   * ```\n   * const documents = await users.aggregate()\n   *   .addStage<{ name: string }>({ $project: { name: true } })\n   *   .toArray(); // type of documents is { name: string }[]\n   * ```\n   */\n  addStage(stage: Document): this;\n  addStage<T = Document>(stage: Document): AggregationCursor<T>;\n  addStage<T = Document>(stage: Document): AggregationCursor<T> {\n    this.throwIfInitialized();\n    if (\n      this.cursorOptions.timeoutMS != null &&\n      this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION &&\n      (stage.$out != null || stage.$merge != null)\n    ) {\n      throw new MongoAPIError('Cannot use $out or $merge stage with ITERATION timeoutMode');\n    }\n    this.pipeline.push(stage);\n    return this as unknown as AggregationCursor<T>;\n  }\n\n  /** Add a group stage to the aggregation pipeline */\n  group<T = TSchema>($group: Document): AggregationCursor<T>;\n  group($group: Document): this {\n    return this.addStage({ $group });\n  }\n\n  /** Add a limit stage to the aggregation pipeline */\n  limit($limit: number): this {\n    return this.addStage({ $limit });\n  }\n\n  /** Add a match stage to the aggregation pipeline */\n  match($match: Document): this {\n    return this.addStage({ $match });\n  }\n\n  /** Add an out stage to the aggregation pipeline */\n  out($out: { db: string; coll: string } | string): this {\n    return this.addStage({ $out });\n  }\n\n  /**\n   * Add a project stage to the aggregation pipeline\n   *\n   * @remarks\n   * In order to strictly type this function you must provide an interface\n   * that represents the effect of your projection on the result documents.\n   *\n   * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.\n   * You should specify a parameterized type to have assertions on your final results.\n   *\n   * @example\n   * ```typescript\n   * // Best way\n   * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });\n   * // Flexible way\n   * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });\n   * ```\n   *\n   * @remarks\n   * In order to strictly type this function you must provide an interface\n   * that represents the effect of your projection on the result documents.\n   *\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling project,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);\n   * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });\n   * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();\n   *\n   * // or always use chaining and save the final cursor\n   *\n   * const cursor = coll.aggregate().project<{ a: string }>({\n   *   _id: 0,\n   *   a: { $convert: { input: '$a', to: 'string' }\n   * }});\n   * ```\n   */\n  project<T extends Document = Document>($project: Document): AggregationCursor<T> {\n    return this.addStage<T>({ $project });\n  }\n\n  /** Add a lookup stage to the aggregation pipeline */\n  lookup($lookup: Document): this {\n    return this.addStage({ $lookup });\n  }\n\n  /** Add a redact stage to the aggregation pipeline */\n  redact($redact: Document): this {\n    return this.addStage({ $redact });\n  }\n\n  /** Add a skip stage to the aggregation pipeline */\n  skip($skip: number): this {\n    return this.addStage({ $skip });\n  }\n\n  /** Add a sort stage to the aggregation pipeline */\n  sort($sort: Sort): this {\n    return this.addStage({ $sort });\n  }\n\n  /** Add a unwind stage to the aggregation pipeline */\n  unwind($unwind: Document | string): this {\n    return this.addStage({ $unwind });\n  }\n\n  /** Add a geoNear stage to the aggregation pipeline */\n  geoNear($geoNear: Document): this {\n    return this.addStage({ $geoNear });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}